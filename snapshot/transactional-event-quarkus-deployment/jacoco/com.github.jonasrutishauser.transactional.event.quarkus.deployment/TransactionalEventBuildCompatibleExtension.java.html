<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TransactionalEventBuildCompatibleExtension.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Transactional Event Library Quarkus Deployment</a> &gt; <a href="index.source.html" class="el_package">com.github.jonasrutishauser.transactional.event.quarkus.deployment</a> &gt; <span class="el_source">TransactionalEventBuildCompatibleExtension.java</span></div><h1>TransactionalEventBuildCompatibleExtension.java</h1><pre class="source lang-java linenums">package com.github.jonasrutishauser.transactional.event.quarkus.deployment;

import static jakarta.interceptor.Interceptor.Priority.LIBRARY_AFTER;
import static java.util.function.Predicate.isEqual;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;

import com.github.jonasrutishauser.transactional.event.api.handler.AbstractHandler;
import com.github.jonasrutishauser.transactional.event.api.handler.EventHandler;
import com.github.jonasrutishauser.transactional.event.api.handler.Handler;
import com.github.jonasrutishauser.transactional.event.api.serialization.EventDeserializer;
import com.github.jonasrutishauser.transactional.event.core.cdi.DefaultEventDeserializer;
import com.github.jonasrutishauser.transactional.event.core.cdi.ExtendedEventDeserializer;
import com.github.jonasrutishauser.transactional.event.core.handler.EventHandlers;
import com.github.jonasrutishauser.transactional.event.quarkus.DefaultEventDeserializerCreator;

import io.quarkus.runtime.Startup;
import jakarta.annotation.Priority;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.enterprise.context.Initialized;
import jakarta.enterprise.event.Observes;
import jakarta.enterprise.inject.Default;
import jakarta.enterprise.inject.build.compatible.spi.BeanInfo;
import jakarta.enterprise.inject.build.compatible.spi.BuildCompatibleExtension;
import jakarta.enterprise.inject.build.compatible.spi.ClassConfig;
import jakarta.enterprise.inject.build.compatible.spi.Enhancement;
import jakarta.enterprise.inject.build.compatible.spi.InjectionPointInfo;
import jakarta.enterprise.inject.build.compatible.spi.Messages;
import jakarta.enterprise.inject.build.compatible.spi.ParameterConfig;
import jakarta.enterprise.inject.build.compatible.spi.Registration;
import jakarta.enterprise.inject.build.compatible.spi.Synthesis;
import jakarta.enterprise.inject.build.compatible.spi.SyntheticBeanBuilder;
import jakarta.enterprise.inject.build.compatible.spi.SyntheticBeanCreator;
import jakarta.enterprise.inject.build.compatible.spi.SyntheticComponents;
import jakarta.enterprise.inject.build.compatible.spi.Types;
import jakarta.enterprise.lang.model.AnnotationInfo;
import jakarta.enterprise.lang.model.declarations.ClassInfo;
import jakarta.enterprise.lang.model.types.ClassType;
import jakarta.enterprise.lang.model.types.ParameterizedType;
import jakarta.enterprise.lang.model.types.Type;
import jakarta.inject.Singleton;

<span class="fc" id="L51">public class TransactionalEventBuildCompatibleExtension implements BuildCompatibleExtension {</span>

<span class="fc" id="L53">    private final Set&lt;ParameterizedType&gt; requiredEventDeserializers = new HashSet&lt;&gt;();</span>
<span class="fc" id="L54">    private final Set&lt;Type&gt; declaredEventDeserializers = new HashSet&lt;&gt;();</span>

<span class="fc" id="L56">    private final Map&lt;ClassInfo, ClassInfo&gt; handlerClass = new HashMap&lt;&gt;();</span>

    @Enhancement(types = Object.class, withSubtypes = true)
    @Priority(LIBRARY_AFTER)
    public void createLockOwnerOnlyOnce(ClassConfig type) {
<span class="fc bfc" id="L61" title="All 2 branches covered.">        if (&quot;com.github.jonasrutishauser.transactional.event.core.store.LockOwner&quot;.equals(type.info().name())) {</span>
<span class="fc" id="L62">            type.removeAnnotation(annotation -&gt; ApplicationScoped.class.getName().equals(annotation.name()));</span>
<span class="fc" id="L63">            type.addAnnotation(Singleton.class);</span>
        }
<span class="fc" id="L65">    }</span>

    @Enhancement(types = com.github.jonasrutishauser.transactional.event.core.cdi.Startup.class, withSubtypes = true)
    @Priority(LIBRARY_AFTER)
    public void fixStaticInitStartup(ClassConfig type) {
<span class="fc bfc" id="L70" title="All 2 branches covered.">        if (!com.github.jonasrutishauser.transactional.event.core.cdi.Startup.class.getName().equals(type.info().name())) {</span>
<span class="fc" id="L71">            changeInitializedApplicationScopedObserverToStartup(type);</span>
        }
<span class="fc" id="L73">    }</span>

    private void changeInitializedApplicationScopedObserverToStartup(ClassConfig type) {
<span class="fc" id="L76">        type.addAnnotation(Startup.class);</span>
<span class="fc" id="L77">        type.methods().forEach(method -&gt; {</span>
<span class="fc bfc" id="L78" title="All 2 branches covered.">            if (!method.parameters().isEmpty()) {</span>
<span class="fc" id="L79">                ParameterConfig firstParameter = method.parameters().get(0);</span>
<span class="pc bpc" id="L80" title="1 of 2 branches missed.">                if (firstParameter.info().hasAnnotation(Observes.class) &amp;&amp; firstParameter.info()</span>
<span class="fc bfc" id="L81" title="All 4 branches covered.">                        .hasAnnotation(annotation -&gt; Initialized.class.getName().equals(annotation.name())</span>
<span class="pc bpc" id="L82" title="1 of 2 branches missed.">                                &amp;&amp; annotation.value().asType().isClass() &amp;&amp; ApplicationScoped.class.getName()</span>
<span class="pc bpc" id="L83" title="1 of 2 branches missed.">                                        .equals(annotation.value().asType().asClass().declaration().name()))) {</span>
<span class="fc" id="L84">                    firstParameter.removeAllAnnotations();</span>
                }
            }
<span class="fc" id="L87">        });</span>
<span class="fc" id="L88">    }</span>

    @Registration(types = Handler.class)
    public void processHandlers(BeanInfo beanInfo, Messages messages) {
<span class="fc" id="L92">        Optional&lt;AnnotationInfo&gt; eventHandlerAnnotation = beanInfo.qualifiers().stream()</span>
<span class="fc" id="L93">                .filter(annotation -&gt; EventHandler.class.getName().equals(annotation.name())).findAny();</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">        if (eventHandlerAnnotation.isEmpty()) {</span>
<span class="fc" id="L95">            messages.error(&quot;EventHandler annotation is missing on bean&quot;, beanInfo);</span>
        } else {
<span class="fc bfc" id="L97" title="All 2 branches covered.">            if (EventHandler.ABSTRACT_HANDLER_TYPE.equals(eventHandlerAnnotation.get().member(&quot;eventType&quot;).asString())) {</span>
<span class="fc" id="L98">                Optional&lt;ParameterizedType&gt; abstractHandlerType = getAbstractHandlerType(beanInfo.types());</span>
<span class="fc bfc" id="L99" title="All 2 branches covered.">                if (abstractHandlerType.isEmpty()) {</span>
<span class="fc" id="L100">                    messages.error(&quot;AbstractHandler type is missing on bean with implicit event type&quot;, beanInfo);</span>
<span class="fc" id="L101">                } else if (beanInfo.types().stream().filter(Type::isClass).map(Type::asClass).map(ClassType::declaration)</span>
<span class="pc bpc" id="L102" title="1 of 2 branches missed.">                        .noneMatch(isEqual(beanInfo.declaringClass()))) {</span>
<span class="fc" id="L103">                    messages.error(beanInfo.declaringClass().simpleName() + &quot; type is missing on bean with implicit event type&quot;, beanInfo);</span>
                } else {
<span class="nc" id="L105">                    handlerClass.put(getClassInfo(abstractHandlerType.get().typeArguments().get(0)), beanInfo.declaringClass());</span>
                }
            }
        }
<span class="fc" id="L109">    }</span>

    @Synthesis
    @Priority(LIBRARY_AFTER)
    public void addEventHandlersBean(SyntheticComponents components) throws ClassNotFoundException {
<span class="fc" id="L114">        List&lt;ClassInfo&gt; types = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L115">        List&lt;ClassInfo&gt; beans = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L116">        handlerClass.forEach((type, bean) -&gt; {</span>
<span class="nc" id="L117">            types.add(type);</span>
<span class="nc" id="L118">            beans.add(bean);</span>
<span class="nc" id="L119">        });</span>
<span class="fc" id="L120">        Class&lt;?&gt; quarkusEventHandlers = Class</span>
<span class="fc" id="L121">                .forName(&quot;com.github.jonasrutishauser.transactional.event.quarkus.handler.QuarkusEventHandlers&quot;);</span>
<span class="fc" id="L122">        addCreator( //</span>
<span class="fc" id="L123">                components.addBean(quarkusEventHandlers) //</span>
<span class="fc" id="L124">                        .type(EventHandlers.class) //</span>
<span class="fc" id="L125">                        .type(quarkusEventHandlers) //</span>
<span class="fc" id="L126">                        .scope(Singleton.class) //</span>
<span class="fc" id="L127">                        .withParam(&quot;types&quot;, types.toArray(ClassInfo[]::new)) //</span>
<span class="fc" id="L128">                        .withParam(&quot;beans&quot;, beans.toArray(ClassInfo[]::new)), //</span>
                quarkusEventHandlers);
<span class="fc" id="L130">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    private &lt;T&gt; void addCreator(SyntheticBeanBuilder&lt;T&gt; builder, Class&lt;?&gt; creatorHost) {
<span class="fc" id="L134">        builder.createWith(</span>
<span class="fc" id="L135">                Arrays.stream(creatorHost.getNestMembers()).filter(SyntheticBeanCreator.class::isAssignableFrom)</span>
<span class="fc" id="L136">                        .map(c -&gt; (Class&lt;? extends SyntheticBeanCreator&lt;T&gt;&gt;) c).findAny()</span>
<span class="fc" id="L137">                        .orElseThrow(IllegalStateException::new));</span>
<span class="fc" id="L138">    }</span>

    @Registration(types = Object.class)
    public void processEventDeserializerInjections(BeanInfo beanInfo, Types types, Messages messages) {
<span class="fc bfc" id="L142" title="All 2 branches covered.">        for (InjectionPointInfo injectionPoint : beanInfo.injectionPoints()) {</span>
<span class="fc" id="L143">            Type type = injectionPoint.type();</span>
<span class="fc bfc" id="L144" title="All 2 branches covered.">            if (type.isParameterizedType()</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">                    &amp;&amp; EventDeserializer.class.getName().equals(type.asParameterizedType().declaration().name())) {</span>
<span class="fc" id="L146">                requiredEventDeserializers.add(type.asParameterizedType());</span>
            }
<span class="fc" id="L148">        }</span>
<span class="fc" id="L149">    }</span>

    @Registration(types = EventDeserializer.class)
    public void processEventDeserializers(BeanInfo beanInfo, Messages messages) {
<span class="nc" id="L153">        declaredEventDeserializers.addAll(beanInfo.types());</span>
<span class="nc" id="L154">    }</span>

    @Synthesis
    @Priority(LIBRARY_AFTER)
    public void addMissingEventDeserializers(SyntheticComponents components) {
<span class="fc" id="L159">        requiredEventDeserializers.removeAll(declaredEventDeserializers);</span>
<span class="fc bfc" id="L160" title="All 2 branches covered.">        for (ParameterizedType type : requiredEventDeserializers) {</span>
<span class="fc" id="L161">            Type eventType = type.typeArguments().get(0);</span>
<span class="pc bpc" id="L162" title="1 of 2 branches missed.">            ClassType eventClass = eventType.isClass() ? eventType.asClass()</span>
<span class="pc" id="L163">                    : eventType.asParameterizedType().genericClass();</span>
<span class="fc" id="L164">            components.addBean(DefaultEventDeserializer.class) //</span>
<span class="fc" id="L165">                .type(type) //</span>
<span class="fc" id="L166">                .type(ExtendedEventDeserializer.class) //</span>
<span class="fc" id="L167">                .scope(Singleton.class) //</span>
<span class="fc" id="L168">                .qualifier(Default.Literal.INSTANCE) //</span>
<span class="fc" id="L169">                .createWith(DefaultEventDeserializerCreator.class) //</span>
<span class="fc" id="L170">                .withParam(DefaultEventDeserializerCreator.TYPE, eventClass.declaration());</span>
<span class="fc" id="L171">        }</span>
<span class="fc" id="L172">    }</span>

    private ClassInfo getClassInfo(Type type) {
<span class="nc bnc" id="L175" title="All 2 branches missed.">        if (type.isParameterizedType()) {</span>
<span class="nc" id="L176">            return type.asParameterizedType().declaration();</span>
        }
<span class="nc" id="L178">        return type.asClass().declaration();</span>
    }

    private Optional&lt;ParameterizedType&gt; getAbstractHandlerType(Collection&lt;Type&gt; types) {
<span class="fc" id="L182">        return types.stream() //</span>
<span class="fc" id="L183">                .filter(Type::isParameterizedType) //</span>
<span class="fc" id="L184">                .map(Type::asParameterizedType) //</span>
<span class="fc" id="L185">                .filter(type -&gt; AbstractHandler.class.getName().equals(type.declaration().name())) //</span>
<span class="fc" id="L186">                .findAny();</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>